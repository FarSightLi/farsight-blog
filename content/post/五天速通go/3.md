+++
author = "FarSightLi"
title = "äº”å¤©é€Ÿé€šgo--æ­å»ºmini-grep(ä¸‰)"
date = "2025-06-15"
description = "é€šè¿‡æ¨¡ä»¿grepå·¥å…·æ¥å¿«é€Ÿå…¥é—¨goè¯­è¨€"
categories = [
    "Go","é¡¹ç›®å®æˆ˜"
]
tags = [
   "Go","é¡¹ç›®å®æˆ˜"
]
+++

## å‰è¨€

ç¬”è€…æœ‰ä¸¤å¹´Javaå¼€å‘ç»éªŒï¼Œç›®å‰éœ€è¦ä¸´æ—¶ç”¨goè¯­è¨€å¼€å‘ä¸€äº›åŠŸèƒ½ï¼Œä¸ºäº†å¿«é€Ÿå…¥æ‰‹Goè¯­è¨€ï¼Œåœ¨ç®€å•äº†è§£åŸºç¡€è¯­æ³•åï¼Œå†³å®šä»¥å®æˆ˜æ¥å·©å›ºçŸ¥è¯†ã€‚

å‚è€ƒäº†ã€ŠRuståœ£ç»ã€‹çš„æ€è·¯ï¼Œå†³å®šå…ˆå¼€å‘ä¸€ä¸ªæ¨¡ä»¿grepçš„å·¥å…·ï¼Œæ¥å¿«é€Ÿå·©å›ºåŸºç¡€è¯­æ³•ã€Goé¡¹ç›®ç®¡ç†ã€‚

ä¸ºç²¾ç®€å†…å®¹ï¼Œæœ¬ç³»åˆ—ä¸åŒ…å«ç¯å¢ƒæ­å»ºç­‰åŸºç¡€éƒ¨åˆ†ï¼ˆç½‘ä¸Šæ•™ç¨‹å†™çš„æ›´æ¸…æ¥šè¯¦ç»†ï¼‰ï¼Œç›´æ¥è®²è§£å¼€å‘æ€è·¯ã€‚å¸Œæœ›èƒ½å¯¹åæ¥è€…æä¾›ä¸€äº›å…¥é—¨æ€è·¯ã€‚

ç¬”è€…æ•´ä½“æ€è·¯ï¼šå¤§è‡´äº†è§£goè¯­è¨€çš„è¯­æ³•ï¼Œäº†è§£æŸä¸ªå·¥å…·çš„å¤§è‡´åŠŸèƒ½ã€å®ç°æ–¹æ³•ã€‚ç„¶åå†è¾…ä»¥AIè¯­æ³•æç¤ºï¼ˆä»…ä»…å‘Šè¯‰æŸä¸ªç»†èŠ‚ï¼Œæ¯”å¦‚å¦‚ä½•è¯»å–å‚æ•°ç­‰ï¼Œè€Œä¸æ˜¯ç›´æ¥è®©aiå®ç°åŠŸèƒ½ï¼‰ã€‚è¿™æ ·ä¾¿èƒ½å¿«é€Ÿå…¥é—¨ä¸€ä¸ªä¸ç®—å¤æ‚çš„è¯­è¨€ã€‚

PSï¼šä»£ç ä»“åº“: https://github.com/FarSightLi/minigrep

## æ­£æ–‡

### æµå¼è¯»å–åˆæ­¥å®ç°

æˆ‘ä»¬é¦–å…ˆä¿®æ”¹ä¹‹å‰è¯»å–è¾“å…¥æµå’Œæ–‡ä»¶çš„æ–¹æ³•ï¼š

```go
var input io.Reader
    // ä»è¾“å…¥æµä¸­è¯»å–
    filepath := cmdArgs.filepath
    if filepath == "" {
        input = os.Stdin
    } else {
        file, e := os.Open(filepath)
        if e != nil {
            if os.IsNotExist(err) {
                fmt.Printf("æ‰¾ä¸åˆ° %s æ–‡ä»¶", filepath)
            }
            if os.IsPermission(err) {
                fmt.Printf("æƒé™è¢«æ‹’ç»")
            }
            input = file
        }
        // defer å»¶è¿Ÿå…³é—­
        defer func(file *os.File) {
            err := file.Close()
            if err != nil {
                fmt.Printf("file close file %v", err)
            }
        }(file)
```

psï¼šä¸ºä»€ä¹ˆfileå¯ä»¥ç›´æ¥èµ‹å€¼ç»™inputï¼Ÿè™½ç„¶çœ‹èµ·æ¥fileæ˜¯ *Fileï¼Œè€Œinputæ˜¯io.Reader

å› ä¸ºFileå®ç°äº†Readerçš„Readå‡½æ•°ï¼Œè¿™æ˜¯ä¸€ç§éšå¼å®ç°ã€‚

æˆ‘ä»¬ä¹‹å‰MatchLinesçš„å‡½æ•°æ¥å—çš„æ˜¯æ•´ä¸ªç›®æ ‡å†…å®¹ï¼ˆstringï¼‰ï¼Œä¸ºäº†å‡å°‘ä»£ç ä¿®æ”¹ï¼Œä¸”å°½å¯èƒ½å¤ç”¨æµ‹è¯•æ–¹æ³•ï¼Œæˆ‘ä»¬ä¸åº”ä¿®æ”¹MatchLinesæ–¹æ³•çš„ç­¾å

æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨mainå‡½æ•°ä¸­å°†inputçš„å†…å®¹è¯»å‡ºæ¥ï¼Œå†ä¼ è¿›MatchLines

```go
    scanner := bufio.NewScanner(input)
    for scanner.Scan() {
        text := scanner.Text()
        lineNum++
        line := MatchLines(text, cmdArgs, printedLine)
        for _, s := range line {
            fmt.Println(s)
        }
    }
```

è¿™æ ·æˆ‘ä»¬å°±æ— éœ€ä¿®æ”¹æ ¸å¿ƒä»£ç ï¼Œè€Œæµ‹è¯•æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿåªéœ€è¦å°†åŸæ¥çš„contentè½¬ä¸ºinputï¼Œå†æ‰‹åŠ¨å¤„ç†scanå³å¯ã€‚ä¸”é‰´äºç°åœ¨çš„MatchLinesåŒ¹é…åˆ°çš„ç»“æœä¹Ÿæ˜¯ç±»ä¼¼äºæµå¼çš„è€Œéä¸€æ¬¡æ€§çš„ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿”å›ç»“æœå­˜èµ·æ¥ï¼ˆæµ‹è¯•æ–¹æ³•çš„æ•°æ®ä¸å¤§ï¼Œå› æ­¤å¯ä»¥è¿™æ ·æ“ä½œæ”¾è‡³å†…å­˜ä¸­ï¼‰

```go
reader := strings.NewReader(tt.content)
            scanner := bufio.NewScanner(reader)
            var results []string
            for scanner.Scan() {
                text := scanner.Text()
                results = append(results, MatchLines(text, tt.cmdArgs, make(map[int]struct{}))...)
            }
```

### å°é‡æ„ï¼Œå…¨é¢é€‚é…æµå¼å¤„ç†

ç»“æœå‘ç°æµ‹è¯•ä¸é€šè¿‡ğŸ˜¥ï¼ŒåŸå› æ˜¯æ­¤å¤„è¿½æº¯ä¸Šä¸‹æ–‡çš„é€»è¾‘å¹¶ä¸é€‚é…æµå¼å¤„ç†ï¼Œéœ€è¦æ”¹è¿›ã€‚

åŸä»£ç çš„é€»è¾‘å¤§è‡´åˆ†ä¸ºå‡ ä¸ªæ¨¡å—:1.è¯»å–ã€è§£æå‚æ•° -> 2.åŠ è½½æ•´ä¸ªå†…å®¹åˆ°å†…å­˜ä¸­ -> 3.åŒ¹é…ã€æ ¼å¼åŒ–è¾“å‡ºï¼ˆå¼ºè€¦åˆäº†ï¼‰ -> 4.è¾“å‡º

æ­£æ˜¯å› ä¸º3æ­¥å¼ºè€¦åˆäº†ï¼Œæ‰€ä»¥ä¹‹å‰çš„ä»£ç ä¸å†é€‚ç”¨äº†ã€‚

ç”±äºæˆ‘ä»¬æ˜¯æµå¼è¯»å–ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨è¯»å–åŒ¹é…è¡Œåï¼Œæƒ³è¦è·å–å‰Xè¡Œå°±ä¸å†é‚£ä¹ˆæ–¹ä¾¿äº†ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦å»ç»´æŠ¤ä¸€ä¸ªç¼“å†²åŒºï¼Œé•¿åº¦è‡³å°‘ä¸º1ï¼ˆå½“å‰è¡Œï¼‰+Beforeè¡Œæ•°ï¼Œè¿™æ ·å°±å¯ä»¥å¿«é€Ÿä»ç¼“å†²åŒºä¸­æ‹¿åˆ°æ‰€éœ€è¦çš„è¡Œã€‚è€Œåœ¨åŒ¹é…åˆ°ç›®æ ‡è¡Œä»¥åï¼Œæ‰“å°Afterè¡Œä¹Ÿå°±ç®€å•äº†ï¼Œåªéœ€è®°å½•è¿˜æœ‰å¤šå°‘åç»­æœªæ‰“å°ï¼Œåœ¨éå†æ¯ä¸€è¡Œæ—¶æ‰“å°å³å¯ã€‚

æ ¹æ®ä»¥ä¸Šæ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹åŸæ¥çš„æ ¸å¿ƒä»£ç è¿›è¡Œæ”¹é€ ã€‚

![](img/2025-06-15-14-28-20-image.png)

æ­¤å¤–ï¼Œä¹‹å‰ä»£ç å…³äºæ ¹æ®aå‚æ•°æ„å»ºAã€Bå‚æ•°çš„é€»è¾‘ä¸åº”æ”¾åœ¨æ‰“å°æ—¶ï¼Œè€Œåº”æ”¾åœ¨è§£æå‚æ•°æ—¶ã€‚

### æŠ¥é”™æç¤ºä¼˜åŒ–:

è‡³æ­¤æˆ‘ä»¬çš„å°ç©å…·minigrepå·²ç»åŸºæœ¬å®Œæˆäº†ã€‚ç°åœ¨è¿˜æœ‰ä¸€ä¸ªé—®é¢˜æˆ‘ä»¬çš„é”™è¯¯è¾“å‡ºä¹Ÿæ˜¯å†™å¾€æ ‡å‡†è¾“å‡ºæµï¼Œè¿™å°±ä¼šé€ æˆæ··ä¹±åŠè¯¯è§£ã€‚æˆ‘ä»¬éœ€è¦å°†é”™è¯¯è¾“å‡ºå’ŒåŒ¹é…åçš„æ‰“å°åŒºåˆ†å¼€æ¥ã€‚åœ¨goä¸­ï¼Œè¿™æ˜¯å¾ˆæ–¹ä¾¿çš„ã€‚åªéœ€è¦å°†åŸæ¥çš„fmt.Printf å‡½æ•°æ¢æˆfmt.Fprintfå³å¯

### TODO è‡ªåŠ¨åŒ–æµ‹è¯•

ç”±äºå·²ç»æ”¹äº†å‡½æ•°å®ç°ï¼Œæ‰€ä»¥ä¹‹å‰çš„å•å…ƒæµ‹è¯•å·²ç»ä¸é€‚ç”¨äº†ï¼Œè€Œç›®å‰çš„å®ç°ä¹Ÿæ¯”è¾ƒéš¾ä»¥ç”¨gotestæµ‹è¯•ï¼Œåç»­æœ‰ç©ºå¯ä»¥å†™shellè„šæœ¬æ¥å®ç°

![](img/2025-06-15-14-43-52-image.png)

æ”¹é€ åçš„å…¨ä»£ç å¦‚ä¸‹ï¼š

```go
package main

import (
    "bufio"
    "errors"
    "flag"
    "fmt"
    "io"
    "os"
    "regexp"
    "strings"
)

type cmdArgs struct {
    filepath            string
    searchText          string
    isIgnoreCase        bool
    isIncludeLineNumber bool
    afterLine           int
    beforeLine          int
    aroundLine          int
    useRegex            bool
    compile             *regexp.Regexp
}

func main() {
    args := os.Args
    cmdArgs, err := parseArgs(args)
    if err != nil {
        fmt.Println(err)
        return
    }
    var input io.Reader
    // ä»è¾“å…¥æµä¸­è¯»å–
    filepath := cmdArgs.filepath
    if filepath == "" {
        input = os.Stdin
    } else {
        file, e := os.Open(filepath)
        if e != nil {
            if os.IsNotExist(e) {
                _, _ = fmt.Fprintf(os.Stderr, "æ‰¾ä¸åˆ° %s æ–‡ä»¶\n", filepath)
            } else if os.IsPermission(e) {
                _, _ = fmt.Fprintf(os.Stderr, "æƒé™è¢«æ‹’ç»\n")
            } else {
                _, _ = fmt.Fprintf(os.Stderr, "æ–‡ä»¶æ‰“å¼€å¤±è´¥: %v", e)
            }
            return
        }
        input = file
        // defer å»¶è¿Ÿå…³é—­
        defer func(file *os.File) {
            _ = file.Close()
        }(file)
    }
    var printedLine = make(map[int]struct{})

    // è¡Œç¼“å†²åŒºï¼Œsizeä¸º 1+before,æœ€å¤§åªéœ€å½“å‰è¡Œ+æŒ‡å®šçš„Bå‚æ•°
    size := 1 + cmdArgs.beforeLine
    buffer := make([]string, 0, size)
    reader := bufio.NewReader(input)
    var lineNum = 0
    scanner := bufio.NewScanner(reader)
    notPrintLine := 0
    for scanner.Scan() {
        line := scanner.Text()
        lineNum++
        buffer = addBuffer(line, buffer, size)
        if notPrintLine > 0 {
            notPrintLine--
            fmt.Println(formatLine(cmdArgs, lineNum, line))
        }
        if isMatch(cmdArgs, line) {
            result := getBeforeLine(cmdArgs, buffer, lineNum, printedLine)
            if len(result) > 0 {
                for _, line := range result {
                    fmt.Println(line)
                }
            }
            // ä¸ç”¨è€ƒè™‘ä¹‹å‰ä¸ºæ‰“å°å®Œçš„è¡Œï¼Œå› æ­¤å†æ¬¡åŒ¹é…åæ‰“å°çš„è¡Œä¸€å®šæ˜¯åŒ…å«äº†ä¸Šæ¬¡æœªæ‰“å°çš„è¡Œ
            notPrintLine = cmdArgs.afterLine
        }
    }
    if err := scanner.Err(); err != nil {
        _, _ = fmt.Fprintf(os.Stderr, "æ‰«æé”™è¯¯: %v\n", err)
    }
}

/**
 * è§£æå‘½ä»¤è¡Œå‚æ•°
 */
func parseArgs(args []string) (cmdArgs, error) {
    // é€‰é¡¹å‚æ•°ç”¨flagè§£æ
    isIgnoreCase := flag.Bool("i", false, "ignore case")
    around := flag.Int("a", 0, "around line")
    before := flag.Int("B", 0, "before line")
    after := flag.Int("A", 0, "after line")
    isIncludeLineNumber := flag.Bool("n", false, "include line number")
    useRegex := flag.Bool("e", false, "use regex module")
    err := flag.CommandLine.Parse(args[1:])
    if err != nil {
        return cmdArgs{}, err
    }

    // éé€‰é¡¹å‚æ•°ç”¨æ™®é€šæ–¹å¼è§£æ
    nonFlagArgs := flag.Args()
    // åªåŒ…å«äº†æœç´¢å†…å®¹
    var searchText string
    var filepath string
    if len(nonFlagArgs) == 1 {
        filepath = ""
        searchText = nonFlagArgs[0]
    } else if len(nonFlagArgs) == 2 {
        filepath = nonFlagArgs[0]
        searchText = nonFlagArgs[1]
    } else {
        return cmdArgs{}, errors.New("å‚æ•°é”™è¯¯,æ ‡å‡†å‚æ•°åªå…è®¸æœ‰æ–‡ä»¶è·¯å¾„å’Œæœç´¢å†…å®¹")
    }
    if *around > 0 {
        after = around
        before = around
    }

    // æå‰ç¼–è¯‘æ­£åˆ™
    var compile *regexp.Regexp
    if *useRegex {
        c, err := regexp.Compile(searchText)
        if err != nil {
            return cmdArgs{}, fmt.Errorf("éæ³•çš„æ­£åˆ™è¡¨è¾¾å¼: %v\n", err)
        }
        compile = c
    }
    return cmdArgs{filepath,
        searchText,
        *isIgnoreCase,
        *isIncludeLineNumber,
        *after,
        *before,
        *around,
        *useRegex,
        compile}, nil
}

/**
 * æœç´¢æ–‡ä»¶å¹¶æ‰“å°å†…å®¹
 */
func isMatch(cmdArgs cmdArgs, line string) bool {
    // ä½¿ç”¨æ­£åˆ™æ¨¡å¼
    if cmdArgs.useRegex {
        return cmdArgs.compile.MatchString(line)
    } else {
        searchText := cmdArgs.searchText
        if cmdArgs.isIgnoreCase {
            searchText = strings.ToLower(searchText)
            line = strings.ToLower(line)
        }
        return strings.Contains(line, searchText)
    }
}

func addBuffer(line string, buffer []string, size int) []string {
    if len(buffer) > size {
        buffer = buffer[1:]
    }
    return append(buffer, line)
}

/**
 * è·å¾—åŒ¹é…è¡Œä¹‹å‰çš„æ‰€æœ‰è¡Œï¼ˆå·²æ ¼å¼åŒ–ï¼‰
 * å…¶å®è¿™é‡Œå¯ä»¥ç›´æ¥æ‰“å°åŒ¹é…çš„è¡Œï¼Œå¯ä»¥èŠ‚çº¦ä¸€å®šå†…å­˜
 */
func getBeforeLine(cmdArgs cmdArgs, buffedLine []string, currentLineNum int, printedLine map[int]struct{}) (result []string) {
    // ç”¨äºè®¡ç®—ã€å®šä½çš„ä¸‹æ ‡ä»¥bufferä½ç½®
    length := len(buffedLine)
    start := length - cmdArgs.beforeLine - 1
    if start < 0 {
        // å³ä»å¤´æ‰“å°
        start = 0
    }
    result = make([]string, 0)
    for index := start; index <= length-1; index++ {
        // indexå¯¹åº”çš„å½“å‰çœŸå®è¡Œå· = å½“å‰è¡Œå· - åç§»é‡ï¼ˆlength-1-indexï¼‰
        lineNum := currentLineNum - (length - 1 - index)
        // å¦‚æœæ‰“å°è¿‡äº†å°±ä¸å†æ‰“å°
        if _, exist := printedLine[lineNum]; exist {
            continue
        }
        result = append(result, formatLine(cmdArgs, lineNum, buffedLine[index]))
        printedLine[lineNum] = struct{}{}
    }
    return result
}

func formatLine(args cmdArgs, index int, line string) string {
    if args.isIncludeLineNumber {
        return fmt.Sprintf("%d:%s", index, line)
    } else {
        return line
    }
}
```

## æ€»ç»“

è‡³æ­¤ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº†mini-grepï¼Œå†æ­¤æ¬¡ä¼˜åŒ–ä¸­ï¼Œæˆ‘ä»¬åŠ æ·±äº†stringåˆ‡ç‰‡ã€mapæ¨¡æ‹Ÿsetçš„æ–¹æ³•ï¼Œæ›´é‡è¦çš„æ˜¯æˆ‘ä»¬æŒæ¡äº†æµå¼è¯»å–çš„æ ¸å¿ƒç”¨æ³•
