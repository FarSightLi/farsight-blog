
+++

author = "FarSightLi"
title = "操作系统（南京大学蒋炎炎）--个人学习笔记"
date = "2025-05-16"
description = "个人学习笔记，主要服务于自己复习"
categories = [
    "操作系统","个人笔记"
]
tags = [
   "操作系统","个人笔记"
]

+++

## 8 终端和进程组、unix shell





## 13 多线程编程入门



...spawn后，共享内存不变，新增新的栈帧

并发vs并行

证明了全局变量是共享的、证明栈的大小（不断递归使用栈空间）



多线程打破了确定性 -> 经典的并发支付、并发sum++

一个小题目：并发执行三个sum. ,sum的最小值

![](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_md_files/f600f690-3c94-11f0-b8e7-657dd91a99a2_20250529215814.jpeg?v=1&type=image&token=V1%253APlTHswpyJ4TAwJO0BUEAJKomA_NiMN0hAjYUbPCPffU)



&#x20;

| t1                        | t2                                | t3                                |
| :------------------------ | :-------------------------------- | :-------------------------------- |
| t = 0，正常执行++和store，则sum=2 |                                   |                                   |
|                           | t=0, t+=1,t=1                     | t=0, t+=1,t=1                     |
| 再加一次并store，则sum=2         |                                   |                                   |
|                           | store， sum = 1                    | store, sum =1                     |
| 此时load出sum =1（被另外两个线程覆盖了） |                                   |                                   |
|                           | load后，t=1，再++                     | load后，t=1，再++                     |
|                           | 正常store，再load，再+1，再正常store后，sum=3 | 正常store，再load，再+1，再正常store后，sum=3 |
| 再进行++，t=2，再load，于是sum最终为2 |                                   |                                   |



编译器会优化程序 编译器假设，没有什么会随意更改程序状态，那么只要优化前后的程序，在程序调用层面上等价，那么语句其实是可以随意调换删除的



那么编写程序时，大部分时候希望编译器优化的，毕竟需要性能，那么有两个不推荐的路子：1.插入不可优化的代码块。2.使用volatile关键字



况且内存也不是真的sharded的，由于物理上的距离、读写的速度，A线程上的内存和B线程上的内存是很有可能不一致的（因为为了保证快，操作系统读取时，是立马返回的，而不是像其他内存块确认是否有修改）
