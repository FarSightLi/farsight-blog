[{"content":"前言 笔者有两年Java开发经验，目前需要临时用go语言开发一些功能，为了快速入手Go语言，在简单了解基础语法后，决定以实战来巩固知识。\n参考了《Rust圣经》的思路，决定先开发一个模仿grep的工具，来快速巩固基础语法、Go项目管理。\n为精简内容，本系列不包含环境搭建等基础部分（网上教程写的更清楚详细），直接讲解开发思路。希望能对后来者提供一些入门思路。\n笔者整体思路：大致了解go语言的语法，了解某个工具的大致功能、实现方法。然后再辅以AI语法提示（仅仅告诉某个细节，比如如何读取参数等，而不是直接让ai实现功能）。这样便能快速入门一个不算复杂的语言。\nPS：代码仓库: https://github.com/FarSightLi/minigrep\n正文 流式读取初步实现 我们首先修改之前读取输入流和文件的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 var input io.Reader // 从输入流中读取 filepath := cmdArgs.filepath if filepath == \u0026#34;\u0026#34; { input = os.Stdin } else { file, e := os.Open(filepath) if e != nil { if os.IsNotExist(err) { fmt.Printf(\u0026#34;找不到 %s 文件\u0026#34;, filepath) } if os.IsPermission(err) { fmt.Printf(\u0026#34;权限被拒绝\u0026#34;) } input = file } // defer 延迟关闭 defer func(file *os.File) { err := file.Close() if err != nil { fmt.Printf(\u0026#34;file close file %v\u0026#34;, err) } }(file) ps：为什么file可以直接赋值给input？虽然看起来file是 *File，而input是io.Reader\n因为File实现了Reader的Read函数，这是一种隐式实现。\n我们之前MatchLines的函数接受的是整个目标内容（string），为了减少代码修改，且尽可能复用测试方法，我们不应修改MatchLines方法的签名\n所以我们可以在main函数中将input的内容读出来，再传进MatchLines\n1 2 3 4 5 6 7 8 9 scanner := bufio.NewScanner(input) for scanner.Scan() { text := scanner.Text() lineNum++ line := MatchLines(text, cmdArgs, printedLine) for _, s := range line { fmt.Println(s) } } 这样我们就无需修改核心代码，而测试方法中，我们也只需要将原来的content转为input，再手动处理scan即可。且鉴于现在的MatchLines匹配到的结果也是类似于流式的而非一次性的，我们可以将返回结果存起来（测试方法的数据不大，因此可以这样操作放至内存中）\n1 2 3 4 5 6 7 reader := strings.NewReader(tt.content) scanner := bufio.NewScanner(reader) var results []string for scanner.Scan() { text := scanner.Text() results = append(results, MatchLines(text, tt.cmdArgs, make(map[int]struct{}))...) } 小重构，全面适配流式处理 结果发现测试不通过😥，原因是此处追溯上下文的逻辑并不适配流式处理，需要改进。\n原代码的逻辑大致分为几个模块:1.读取、解析参数 -\u0026gt; 2.加载整个内容到内存中 -\u0026gt; 3.匹配、格式化输出（强耦合了） -\u0026gt; 4.输出\n正是因为3步强耦合了，所以之前的代码不再适用了。\n由于我们是流式读取，所以我们在读取匹配行后，想要获取前X行就不再那么方便了。所以我们需要去维护一个缓冲区，长度至少为1（当前行）+Before行数，这样就可以快速从缓冲区中拿到所需要的行。而在匹配到目标行以后，打印After行也就简单了，只需记录还有多少后续未打印，在遍历每一行时打印即可。\n根据以上思路，我们可以对原来的核心代码进行改造。\n此外，之前代码关于根据a参数构建A、B参数的逻辑不应放在打印时，而应放在解析参数时。\n报错提示优化: 至此我们的小玩具minigrep已经基本完成了。现在还有一个问题我们的错误输出也是写往标准输出流，这就会造成混乱及误解。我们需要将错误输出和匹配后的打印区分开来。在go中，这是很方便的。只需要将原来的fmt.Printf 函数换成fmt.Fprintf即可\nTODO 自动化测试 由于已经改了函数实现，所以之前的单元测试已经不适用了，而目前的实现也比较难以用gotest测试，后续有空可以写shell脚本来实现\n改造后的全代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 package main import ( \u0026#34;bufio\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;regexp\u0026#34; \u0026#34;strings\u0026#34; ) type cmdArgs struct { filepath string searchText string isIgnoreCase bool isIncludeLineNumber bool afterLine int beforeLine int aroundLine int useRegex bool compile *regexp.Regexp } func main() { args := os.Args cmdArgs, err := parseArgs(args) if err != nil { fmt.Println(err) return } var input io.Reader // 从输入流中读取 filepath := cmdArgs.filepath if filepath == \u0026#34;\u0026#34; { input = os.Stdin } else { file, e := os.Open(filepath) if e != nil { if os.IsNotExist(e) { _, _ = fmt.Fprintf(os.Stderr, \u0026#34;找不到 %s 文件\\n\u0026#34;, filepath) } else if os.IsPermission(e) { _, _ = fmt.Fprintf(os.Stderr, \u0026#34;权限被拒绝\\n\u0026#34;) } else { _, _ = fmt.Fprintf(os.Stderr, \u0026#34;文件打开失败: %v\u0026#34;, e) } return } input = file // defer 延迟关闭 defer func(file *os.File) { _ = file.Close() }(file) } var printedLine = make(map[int]struct{}) // 行缓冲区，size为 1+before,最大只需当前行+指定的B参数 size := 1 + cmdArgs.beforeLine buffer := make([]string, 0, size) reader := bufio.NewReader(input) var lineNum = 0 scanner := bufio.NewScanner(reader) notPrintLine := 0 for scanner.Scan() { line := scanner.Text() lineNum++ buffer = addBuffer(line, buffer, size) if notPrintLine \u0026gt; 0 { notPrintLine-- fmt.Println(formatLine(cmdArgs, lineNum, line)) } if isMatch(cmdArgs, line) { result := getBeforeLine(cmdArgs, buffer, lineNum, printedLine) if len(result) \u0026gt; 0 { for _, line := range result { fmt.Println(line) } } // 不用考虑之前为打印完的行，因此再次匹配后打印的行一定是包含了上次未打印的行 notPrintLine = cmdArgs.afterLine } } if err := scanner.Err(); err != nil { _, _ = fmt.Fprintf(os.Stderr, \u0026#34;扫描错误: %v\\n\u0026#34;, err) } } /** * 解析命令行参数 */ func parseArgs(args []string) (cmdArgs, error) { // 选项参数用flag解析 isIgnoreCase := flag.Bool(\u0026#34;i\u0026#34;, false, \u0026#34;ignore case\u0026#34;) around := flag.Int(\u0026#34;a\u0026#34;, 0, \u0026#34;around line\u0026#34;) before := flag.Int(\u0026#34;B\u0026#34;, 0, \u0026#34;before line\u0026#34;) after := flag.Int(\u0026#34;A\u0026#34;, 0, \u0026#34;after line\u0026#34;) isIncludeLineNumber := flag.Bool(\u0026#34;n\u0026#34;, false, \u0026#34;include line number\u0026#34;) useRegex := flag.Bool(\u0026#34;e\u0026#34;, false, \u0026#34;use regex module\u0026#34;) err := flag.CommandLine.Parse(args[1:]) if err != nil { return cmdArgs{}, err } // 非选项参数用普通方式解析 nonFlagArgs := flag.Args() // 只包含了搜索内容 var searchText string var filepath string if len(nonFlagArgs) == 1 { filepath = \u0026#34;\u0026#34; searchText = nonFlagArgs[0] } else if len(nonFlagArgs) == 2 { filepath = nonFlagArgs[0] searchText = nonFlagArgs[1] } else { return cmdArgs{}, errors.New(\u0026#34;参数错误,标准参数只允许有文件路径和搜索内容\u0026#34;) } if *around \u0026gt; 0 { after = around before = around } // 提前编译正则 var compile *regexp.Regexp if *useRegex { c, err := regexp.Compile(searchText) if err != nil { return cmdArgs{}, fmt.Errorf(\u0026#34;非法的正则表达式: %v\\n\u0026#34;, err) } compile = c } return cmdArgs{filepath, searchText, *isIgnoreCase, *isIncludeLineNumber, *after, *before, *around, *useRegex, compile}, nil } /** * 搜索文件并打印内容 */ func isMatch(cmdArgs cmdArgs, line string) bool { // 使用正则模式 if cmdArgs.useRegex { return cmdArgs.compile.MatchString(line) } else { searchText := cmdArgs.searchText if cmdArgs.isIgnoreCase { searchText = strings.ToLower(searchText) line = strings.ToLower(line) } return strings.Contains(line, searchText) } } func addBuffer(line string, buffer []string, size int) []string { if len(buffer) \u0026gt; size { buffer = buffer[1:] } return append(buffer, line) } /** * 获得匹配行之前的所有行（已格式化） * 其实这里可以直接打印匹配的行，可以节约一定内存 */ func getBeforeLine(cmdArgs cmdArgs, buffedLine []string, currentLineNum int, printedLine map[int]struct{}) (result []string) { // 用于计算、定位的下标以buffer位置 length := len(buffedLine) start := length - cmdArgs.beforeLine - 1 if start \u0026lt; 0 { // 即从头打印 start = 0 } result = make([]string, 0) for index := start; index \u0026lt;= length-1; index++ { // index对应的当前真实行号 = 当前行号 - 偏移量（length-1-index） lineNum := currentLineNum - (length - 1 - index) // 如果打印过了就不再打印 if _, exist := printedLine[lineNum]; exist { continue } result = append(result, formatLine(cmdArgs, lineNum, buffedLine[index])) printedLine[lineNum] = struct{}{} } return result } func formatLine(args cmdArgs, index int, line string) string { if args.isIncludeLineNumber { return fmt.Sprintf(\u0026#34;%d:%s\u0026#34;, index, line) } else { return line } } 总结 至此，我们已经完成了mini-grep，再此次优化中，我们加深了string切片、map模拟set的方法，更重要的是我们掌握了流式读取的核心用法\n","date":"2025-06-15T00:00:00Z","permalink":"//ind:1313/p/%E4%BA%94%E5%A4%A9%E9%80%9F%E9%80%9Ago--%E6%90%AD%E5%BB%BAmini-grep%E4%B8%89/","title":"五天速通go--搭建mini-grep(三)"},{"content":"前言 笔者有两年Java开发经验，目前需要临时用go语言开发一些功能，为了快速入手Go语言，在简单了解基础语法后，决定以实战来巩固知识。\n参考了《Rust圣经》的思路，决定先开发一个模仿grep的工具，来快速巩固基础语法、Go项目管理。\n为精简内容，本系列不包含环境搭建等基础部分（网上教程写的更清楚详细），直接讲解开发思路。希望能对后来者提供一些入门思路。\n笔者整体思路：大致了解go语言的语法，了解某个工具的大致功能、实现方法。然后再辅以AI语法提示（仅仅告诉某个细节，比如如何读取参数等，而不是直接让ai实现功能）。这样便能快速入门一个不算复杂的语言。\nPS：代码仓库: https://github.com/FarSightLi/minigrep\n正文 功能拓展 在上一篇中，我们初步完成了一个及其简陋的grep程序，在这一节中，我们将逐步拓展功能。\n在笔者日常工作中，-An(匹配列的下n行)， -an（匹配列的上下n行）、-Bn（匹配列的上n行）、-n（显示行号）、-i（忽略大小写）、-e（启用正则匹配）。在这篇中，我们就拓展这几种参数功能。\n优化参数获取 在上一篇的原始版本中，我们使用这种 方式获得文件路径和搜索文本。这两个参数可以被视为”必须参数“（虽然filepath不一定必须，可以从输入流中获取，当然这是后话了）。而刚刚提到的诸如 -a等参数却可以使用任意个。所以我们通过从数组args的指定位置获取的方法就不适用了。这种参数称之为选项参数\n1 2 filepath = args[1] searchText = args[2] 在golang中，选项参数可以用go的函数flag.CommandLine.Parse(args[1:])获取\n使用方法如下：\n1 2 3 4 5 // 选项参数用flag解析 isIgnoreCase := flag.Bool(\u0026#34;i\u0026#34;, false, \u0026#34;ignore case\u0026#34;) around := flag.Int(\u0026#34;a\u0026#34;, 0, \u0026#34;around line\u0026#34;) isIncludeLineNumber := flag.Bool(\u0026#34;n\u0026#34;, false, \u0026#34;include line number\u0026#34;) err := flag.CommandLine.Parse(args[1:]) 需要注意的是，flag.Int获得的是指针类型\nargs从1号位切片是因为0号位是我们的程序名\n使用时，这些选项参数如这样使用：\n1 go run main.go -i -a 2 -n #{文件路径} #{搜索内容} 结构体 虽然golang的方法可以拥有多个返回值，但是解析完的多个参数并不适合直接返回，可以用结构体包装后返回\n结构体大致如下：\n1 2 3 4 5 6 7 8 9 type cmdArgs struct { filepath string searchText string isIgnoreCase bool isIncludeLineNumber bool afterLine int beforeLine int aroundLine int } 实现思路 可以发现，这些参数中，-i、-e等选项是用于决定如何匹配文本的，而-a -n等参数实则是控制输出的。所以我们可以将其抽象为两个函数，一个用于在遍历每行内容时匹配文本，另一个用于在匹配后输出内容\n核心代码大致实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /** * 搜索文件并打印内容 */ func searchFile(content string, cmdArgs cmdArgs) { if content == \u0026#34;\u0026#34; { return } searchText := cmdArgs.searchText // 提前编译正则 compile, err := regexp.Compile(searchText) if err != nil { _, _ = fmt.Fprintf(os.Stderr, \u0026#34;非法的正则表达式: %v\\n\u0026#34;, err) return } lines := strings.Split(content, \u0026#34;\\n\u0026#34;) for lineNum, line := range lines { // 使用正则模式 if cmdArgs.useRegex { if compile.MatchString(line) { printLine(cmdArgs, lines, lineNum) } } else { if cmdArgs.isIgnoreCase { searchText = strings.ToLower(cmdArgs.searchText) line = strings.ToLower(line) } if strings.Contains(line, searchText) { printLine(cmdArgs, lines, lineNum) } } } } /** * 根据参数打印匹配上的行 */ func printLine(cmdArgs cmdArgs, lines []string, lineNum int) { var a, b int if cmdArgs.aroundLine \u0026gt; 0 { a = cmdArgs.aroundLine b = cmdArgs.aroundLine } else { a = cmdArgs.afterLine b = cmdArgs.beforeLine } start := lineNum - a if start \u0026lt; 0 { start = 0 } end := lineNum + b length := len(lines) if end \u0026gt;= length { end = length - 1 } for index := start; index \u0026lt;= end; index++ { if cmdArgs.isIncludeLineNumber { fmt.Printf(\u0026#34;%d:%s\\n\u0026#34;, index, lines[index]) } else { fmt.Println(lines[index]) } } } 单元测试 为了方便测试，匹配行后不再直接输出，而是返回数组，最后同意输出（由AI生成）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 func TestMatchLines(t *testing.T) { tests := []struct { name string content string cmdArgs cmdArgs expected []string }{ { name: \u0026#34;普通匹配\u0026#34;, content: \u0026#34;apple banana\\ncherry apple\\ndate\u0026#34;, cmdArgs: cmdArgs{ searchText: \u0026#34;apple\u0026#34;, }, expected: []string{\u0026#34;apple banana\u0026#34;, \u0026#34;cherry apple\u0026#34;}, }, { name: \u0026#34;忽略大小写\u0026#34;, content: \u0026#34;Apple banana\\nCHERRY APPLE\u0026#34;, cmdArgs: cmdArgs{ searchText: \u0026#34;apple\u0026#34;, isIgnoreCase: true, }, expected: []string{\u0026#34;Apple banana\u0026#34;, \u0026#34;CHERRY APPLE\u0026#34;}, }, { name: \u0026#34;正则匹配以 a 开头\u0026#34;, content: \u0026#34;apple banana\\ngrape apple\\nant\u0026#34;, cmdArgs: cmdArgs{ searchText: \u0026#34;^[aA]\u0026#34;, useRegex: true, }, expected: []string{\u0026#34;apple banana\u0026#34;, \u0026#34;ant\u0026#34;}, }, { name: \u0026#34;上下文两行\u0026#34;, content: \u0026#34;line1\\nline2\\napple\\nline4\\nline5\u0026#34;, cmdArgs: cmdArgs{ searchText: \u0026#34;apple\u0026#34;, aroundLine: 2, }, expected: []string{\u0026#34;line1\u0026#34;, \u0026#34;line2\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;line4\u0026#34;, \u0026#34;line5\u0026#34;}, }, { name: \u0026#34;显示行号\u0026#34;, content: \u0026#34;hello\\nworld\\nhello again\u0026#34;, cmdArgs: cmdArgs{ searchText: \u0026#34;hello\u0026#34;, isIncludeLineNumber: true, }, expected: []string{\u0026#34;0:hello\u0026#34;, \u0026#34;2:hello again\u0026#34;}, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { results := MatchLines(tt.content, tt.cmdArgs, make(map[int]struct{})) if len(results) != len(tt.expected) { t.Errorf(\u0026#34;预期 %d 行，实际 %d 行\u0026#34;, len(tt.expected), len(results)) return } for i := range results { if results[i] != tt.expected[i] { t.Errorf(\u0026#34;第 %d 行期望 %q，实际 %q\u0026#34;, i, tt.expected[i], results[i]) } } }) } } 代码全文 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 package main import ( \u0026#34;errors\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;regexp\u0026#34; \u0026#34;strings\u0026#34; ) func main() { args := os.Args cmdArgs, err := parseArgs(args) if err != nil { fmt.Println(err) return } content := \u0026#34;\u0026#34; // 从输入流中读取 if cmdArgs.filepath == \u0026#34;\u0026#34; { bytes, err := io.ReadAll(os.Stdin) if err != nil { fmt.Println(\u0026#34;读取输入流出错\u0026#34;) return } content = string(bytes) } else { contentByte, e := readFile(cmdArgs.filepath) if e != nil { fmt.Println(e) return } content = contentByte } var printedLine = make(map[int]struct{}) line := MatchLines(content, cmdArgs, printedLine) for _, s := range line { fmt.Println(s) } } type cmdArgs struct { filepath string searchText string isIgnoreCase bool isIncludeLineNumber bool afterLine int beforeLine int aroundLine int useRegex bool } /** * 解析命令行参数 */ func parseArgs(args []string) (cmdArgs, error) { // 选项参数用flag解析 isIgnoreCase := flag.Bool(\u0026#34;i\u0026#34;, false, \u0026#34;ignore case\u0026#34;) around := flag.Int(\u0026#34;a\u0026#34;, 0, \u0026#34;around line\u0026#34;) before := flag.Int(\u0026#34;B\u0026#34;, 0, \u0026#34;before line\u0026#34;) after := flag.Int(\u0026#34;A\u0026#34;, 0, \u0026#34;after line\u0026#34;) isIncludeLineNumber := flag.Bool(\u0026#34;n\u0026#34;, false, \u0026#34;include line number\u0026#34;) useRegex := flag.Bool(\u0026#34;e\u0026#34;, false, \u0026#34;use regex module\u0026#34;) err := flag.CommandLine.Parse(args[1:]) if err != nil { return cmdArgs{}, err } // 非选项参数用普通方式解析 nonFlagArgs := flag.Args() // 只包含了搜索内容 var searchText string var filepath string if len(nonFlagArgs) == 1 { filepath = \u0026#34;\u0026#34; searchText = nonFlagArgs[0] } else if len(nonFlagArgs) == 2 { filepath = nonFlagArgs[0] searchText = nonFlagArgs[1] } else { return cmdArgs{}, errors.New(\u0026#34;参数错误,标准参数只允许有文件路径和搜索内容\u0026#34;) } return cmdArgs{filepath, searchText, *isIgnoreCase, *isIncludeLineNumber, *after, *before, *around, *useRegex}, nil } /** * 搜索文件并打印内容 */ func MatchLines(content string, cmdArgs cmdArgs, printedLine map[int]struct{}) []string { if content == \u0026#34;\u0026#34; { return []string{} } searchText := cmdArgs.searchText // 提前编译正则 var compile *regexp.Regexp if cmdArgs.useRegex { c, err := regexp.Compile(searchText) if err != nil { _, _ = fmt.Fprintf(os.Stderr, \u0026#34;非法的正则表达式: %v\\n\u0026#34;, err) return []string{} } compile = c } var matchedLines []string lines := strings.Split(content, \u0026#34;\\n\u0026#34;) for lineNum, line := range lines { // 使用正则模式 if cmdArgs.useRegex { if compile.MatchString(line) { matchedLines = append(matchedLines, formatLine(cmdArgs, lines, lineNum, printedLine)...) } } else { if cmdArgs.isIgnoreCase { searchText = strings.ToLower(cmdArgs.searchText) line = strings.ToLower(line) } if strings.Contains(line, searchText) { matchedLines = append(matchedLines, formatLine(cmdArgs, lines, lineNum, printedLine)...) } } } return matchedLines } /** * 根据参数打印匹配上的行 */ func formatLine(cmdArgs cmdArgs, lines []string, lineNum int, printedLine map[int]struct{}) []string { var matchedLines []string var a, b int if cmdArgs.aroundLine \u0026gt; 0 { a = cmdArgs.aroundLine b = cmdArgs.aroundLine } else { a = cmdArgs.afterLine b = cmdArgs.beforeLine } start := lineNum - b if start \u0026lt; 0 { start = 0 } end := lineNum + a length := len(lines) if end \u0026gt;= length { end = length - 1 } for index := start; index \u0026lt;= end; index++ { // 如果打印过了就不再打印 if _, exist := printedLine[index]; exist { continue } if cmdArgs.isIncludeLineNumber { matchedLines = append(matchedLines, fmt.Sprintf(\u0026#34;%d:%s\u0026#34;, index, lines[index])) } else { matchedLines = append(matchedLines, fmt.Sprintf(lines[index])) } printedLine[index] = struct{}{} } return matchedLines } func readFile(filepath string) (string, error) { // 检查文件是否存在 info, err := os.Stat(filepath) if os.IsNotExist(err) { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;找不到 %s 文件\u0026#34;, filepath) } // 检查是否是目录 if err == nil \u0026amp;\u0026amp; info.IsDir() { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;%s 是一个目录而非文件\u0026#34;, filepath) } // 读取文件内容 content, err := os.ReadFile(filepath) if err != nil { if os.IsPermission(err) { return \u0026#34;\u0026#34;, errors.New(\u0026#34;权限被拒绝\u0026#34;) } return \u0026#34;\u0026#34;, err } return string(content), nil } 总结 通过这次优化，我们用到了更多golang的特性，比如用map模拟set、读取参数中的选项参数、正则使用 以及 数组添加等。\n但是稍微有些经验的读者都能发现一个严重问题 ：内存大爆炸\n我们的输入流、从文件读出来的内容都放到了内存中，这是一个严重隐患，我们将在下一篇中优化此项\n","date":"2025-06-07T00:00:00Z","permalink":"//ind:1313/p/%E4%BA%94%E5%A4%A9%E9%80%9F%E9%80%9Ago--%E6%90%AD%E5%BB%BAmini-grep%E4%BA%8C/","title":"五天速通go--搭建mini-grep(二)"},{"content":"Kafka要解决的问题： 原视频：\n【消息队列Kafka是什么？架构是怎么样的？5分钟快速入门】https://www.bilibili.com/video/BV1TT421y79S?vd_source=f2fbf19a95f21a30c8f56673d2b182b7\n消费者与生产者之间的生产速度和消费速度是不匹配的。如果生产的消息都往消费者塞，那么消费者很容易挂掉。那么我们可以把消息发往一个消息队列。消息队列可以起到 1削峰填谷 2.解耦 3.异步 等作用。但如果消息队列与消费者耦合，会有很多问题。于是需要把消息队列抽象出来，而Kafka就是消息队列的一种中间件。\n随着消费者和生产者的增加，消息的吞吐增加了。然而吞吐量到达一定程度，那么多个消费者/生产者就会共同争抢一个消息队列，会有等待时间。这样就出现了性能问题。那么这时候就可以增加消息队列，指定不同种类的消费者和生产者使用某一个消息队列\u0026ndash;这个就是topic。单个topic数据量过大时，那么就可以将单个topic拆开，这就是partition，然后每个消费者消费不同partition。\n如果多个partition都放在同一台机器上，则会对机器造成性能压力，那么可以将不同partition放在不同机器上，那么每个机器就是一个borker。\n如果broker的机器挂掉了，那么数据就全丢了。为了做到高可用性，往往将partition做备份即副本replicas。\nleader负责读写、follower负责同步leader。为了以防万一，往往还会对数据进行持久化。将数据写到磁盘上，然后根据某种策略清理磁盘\n消费组 consumer group相关概念 消费组是为了解决：单个消费者消费速度跟不上生产者，那么就增加多个消费者组成消费组来共同消费某个topic。\nkafka控制了在一个消费组中，，同一 Partition 内的消息在同一个 Consumer Group 中只会被一个消费者实例处理。而不同消费组之间是可以独立的消费同一条消息。\n消费组订阅的是topic，订阅后，调度者coordinate就会将不同partition分配给不同消费者实例。调度员coordinate会在消费者增减、partition增减、消费组订阅新topic时进行重新分配rebalance。rebalance时group中的所有消费者会暂停消费至重新分配完毕\n生产者的核心机制 消息分发策略：生产者要指定topic，那么进入topic的消息应该去哪个partition？这有不同策略，比如轮询分配，比如按某个规则hash分配。\nACK机制：可以不确认（acks=0）、leader确认（acks=1）、leader及follower确认（acks=all）\nacks=all时，还有一个参数min.insync.replicas即isr的副本大于等于这个参数时，就可以向生产者返回ack\n发送时，消息先放到发送缓冲区中，然后再攒批聚合发送\n高水位线 high watermark机制 hw标记了一个位置\u0026ndash;所有副本都已经同步的消息offset位置，消费者只能读取到小于hw的消息\nAI画的图：\nOffset 0 1 2 3 4 5 6 消息 A B C D E F G 状态 ✅ ✅ ✅ ✅ 🚫 🚫 🚫 1 2 ↑ HW=4 (安全水位线) 此时当所有follower确认消息E持久化后，HW就会更新为5\nHW只由Leader进行更新维护，会由kafka的各种强制刷盘机制写到磁盘上\n疑问：\n1.为什么有topic和partition的概念，直接新增消息队列不就行了？\ntopic是指Kafka将一些生产、消费的数据抽象出来，方便不同功能的生产者消费者操作消息。也就是起到分类功能。还可以使生产者消费者只关心如何收发数据，生产者不必额外设计标识使消费者正确消费。这是一种逻辑上的分区。\n而partition将topic分开，这种分区是一种物理上的分区。不同partition分布在不同broker或磁盘上，使减少读写io的冲突。此外，partition还提供了并发消费的能力。\n2.假如副本flower尚未拉取同步完leader的消息，lead挂掉了，此时选举出来的leader岂不是会丢消息？\n这是AI给的场景复现：\n初始状态\nTopic 分区 P0 有 3 个副本：Leader L1，Follower F2，Follower F3（ISR = [L1, F2, F3]）\n生产者发送消息 M1 到 L1，L1 将 M1 写入本地日志（但尚未同步给 Follower）\n故障发生\nL1 突然宕机（此时 M1 未同步给任何 Follower）\n系统需选举新 Leader（F2 或 F3）\n风险 若选出的新 Leader 是 F2 或 F3，它们从未收到过 M1，导致 M1 永久丢失！\n解决方案：1、ACK策略指定all 则只要生产者确认成功，那所有ISR都有数据，不会丢失\n假如acks=1，那么在此场景中，\nLeader (L) 已写入消息 E (Offset=4)\nF1 同步了 E → ISR = [L, F1, F2]\nF2 未同步 E（因网络延迟）\n此时 HW 仍为 4（因 F2 未确认，消息 E 不算安全）\n突发故障：Leader (L) 宕机！\nF1被选举为Leader，会进行检查，发现HW=4，则将消息E丢弃。而F2检查后不做处理（因为符合HW）。然后就是正常的同步数据流程\n消费者的核心机制 TODO\n从代码看不同acks处理 以下代码由AI提供，暂未验证是否准确\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // -------------------------- // CASE 1: acks=0 (最高吞吐) // -------------------------- props.put(\u0026#34;acks\u0026#34;, \u0026#34;0\u0026#34;); // 无需确认 producer.send(new ProducerRecord\u0026lt;\u0026gt;(\u0026#34;topic\u0026#34;, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); // 特点：发送即忘，不处理响应（可能丢失） // -------------------------- // CASE 2: acks=1 (平衡模式) // -------------------------- props.put(\u0026#34;acks\u0026#34;, \u0026#34;1\u0026#34;); // Leader 确认 producer.send(new ProducerRecord\u0026lt;\u0026gt;(\u0026#34;topic\u0026#34;, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;), (metadata, e) -\u0026gt; { if (e != null) log.error(\u0026#34;发送失败\u0026#34;, e); // 处理失败 else log.debug(\u0026#34;发送成功: {}\u0026#34;, metadata.offset()); }); // 特点：处理Leader响应，网络异常可能重复 // -------------------------- // CASE 3: acks=all (高可靠) // -------------------------- props.put(\u0026#34;acks\u0026#34;, \u0026#34;all\u0026#34;); props.put(\u0026#34;min.insync.replicas\u0026#34;, \u0026#34;2\u0026#34;); // 要求至少2个副本同步 producer.send(new ProducerRecord\u0026lt;\u0026gt;(\u0026#34;topic\u0026#34;, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;), (metadata, e) -\u0026gt; { if (e != null) { if (e instanceof NotEnoughReplicasException) { // ISR副本不足时的特殊处理 } retryOrFail(e); // 自定义重试逻辑 } }); // 特点：严格一致性保障，需处理副本同步异常 可以看到，在acks=0的情况下，是没有回调方法的，所以也就拿不到元数据和异常信息（当然，offset=0时默认发送成功），而在acks=1或all的情况下，生产者是可以拿到发送成功后的offset等数据，假如发送失败也可以拿到拿到异常原因，但是发送异常后是否重发或其他逻辑，其实是生产者的代码自定义的，kafka对此并无要求？\n","date":"2025-06-05T00:00:00Z","permalink":"//ind:1313/p/kafka%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E7%90%86%E8%AE%BA/","title":"kafka基础架构理论"},{"content":"8 终端和进程组、unix shell 终端是从打字机、电报等演进而来的\n现在的终端其实是pts-\u0026gt;伪终端pseudo terminal，作为一个中间层，连接了真正的终端和输入设备\n不管是系统启动还是远程登陆，都会分配一个tty\n终端只传输字符，不管ctrl+c还是d\u0026hellip;.（都代表不同的控制信号），都发给操作系统\nctrl+z退出程序，放在后台跑，相当于最小化。而jobs可以查看所有运行中的后台程序， fg %#{id} 即可恢复\n操作系统维护了终端与对应的运行程序group的关系。每个进程都有一个sessionid，关联了终端。还有一个小分组，process group id，只有一个前台进程组，ctrl+c时关闭所有前台进程组。\n这里讨论了：这是一种遗留的历史问题，可以设计的更简洁，只需要保留进程组就行。还有Android的实现机制\n13 多线程编程入门 \u0026hellip;spawn后，共享内存不变，新增新的栈帧\n并发vs并行\n证明了全局变量是共享的、证明栈的大小（不断递归使用栈空间）\n多线程打破了确定性 -\u0026gt; 经典的并发支付、并发sum++\n一个小题目：并发执行三个sum. ,sum的最小值\nt1 t2 t3 t = 0，正常执行++和store，则sum=2 t=0, t+=1,t=1 t=0, t+=1,t=1 再加一次并store，则sum=2 store， sum = 1 store, sum =1 此时load出sum =1（被另外两个线程覆盖了） load后，t=1，再++ load后，t=1，再++ 正常store，再load，再+1，再正常store后，sum=3 正常store，再load，再+1，再正常store后，sum=3 再进行++，t=2，再load，于是sum最终为2 编译器会优化程序 编译器假设，没有什么会随意更改程序状态，那么只要优化前后的程序，在程序调用层面上等价，那么语句其实是可以随意调换删除的\n那么编写程序时，大部分时候希望编译器优化的，毕竟需要性能，那么有两个不推荐的路子：1.插入不可优化的代码块。2.使用volatile关键字\n况且内存也不是真的sharded的，由于物理上的距离、读写的速度，A线程上的内存和B线程上的内存是很有可能不一致的（因为为了保证快，操作系统读取时，是立马返回的，而不是像其他内存块确认是否有修改）\n27 虚拟机、容器、微服务 一开始，是Full System Emulation，写一个程序，模拟整个操作系统。有致命缺陷：性能非常慢\n实际上，我们的应用大部分都不在内核上运行。所以可以将虚拟机的用户态部分直接放到宿主机上运行（将物理页映射到虚拟页），只有涉及到系统调用时，才放到虚拟机中执行。而发展到今天，cpu已经自支持虚拟化了，虚拟机和宿主机用的不同页表，syscall直接运行在虚拟页表上。\n虚拟机可以保存系统状态，一旦保存，可以做时空转换。虚拟机的初始状态是确定的，是一个初始状态的虚拟机，可以将所有状态转换都记录下来\n然而，没必要用一个模拟程序来模拟操作系统，操作系统可以自己虚拟化自己。加一个osid，即可区分不同进程树（一个进程可以fork另外一棵进程树）。这就是linux的namespaces，有一些东西需要区分，如mnt、pid、cgroup、net、user、time、ipc、time等。cgroup控制了不同namespaces的资源上限\n这其实也就是容器，开销更小，只是容器安全性略低\n甚至可以更进一步，连容器概念都不要了：serverless，function as a service。直接将函数放在云上。\n","date":"2025-05-16T00:00:00Z","permalink":"//ind:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%92%8B%E7%82%8E%E7%82%8E--%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"操作系统（南京大学蒋炎炎）--个人学习笔记"},{"content":"前言 笔者有两年Java开发经验，目前需要临时用go语言开发一些功能，为了快速入手Go语言，在简单了解基础语法后，决定以实战来巩固知识。\n参考了《Rust圣经》的思路，决定先开发一个模仿grep的工具，来快速巩固基础语法、Go项目管理。\n为精简内容，本系列不包含环境搭建等基础部分（网上教程写的更清楚详细），直接讲解开发思路。希望能对后来者提供一些入门思路。\n笔者整体思路：大致了解go语言的语法，了解某个工具的大致功能、实现方法。然后再辅以AI语法提示（仅仅告诉某个细节，比如如何读取参数等，而不是直接让ai实现功能）。这样便能快速入门一个不算复杂的语言。\nPS：代码仓库: GitHub - FarSightLi/minigrep\ngrep命令简介 grep是一个最初用于Unix操作系统的命令行工具。在给出文件列表或标准输入后，grep会对匹配一个或多个正则表达式的文本进行搜索，并只输出匹配（或者不匹配）的行或文本。\n\u0026ndash; wiki百科\ngrep的一个经典用法是：\n1 grep /data/test.txt searchContent 其中，/data/test.txt 是要搜索的文件列表， searchContent是我们要搜索的内容。这是一种最基本的功能。\n搭建基本框架 我们的minigrep至少要先能获取到用户的目标 :文件列表及搜索内容 \u0026ndash; 即参数列表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 读取参数列表 args := os.Args // 文件路径 filepath := args[1] // 搜索内容 searchText := args[2] content, e := os.ReadFile(filepath) if e != nil { panic(\u0026#34;Usage: illegal file name\u0026#34;) } // 假装已经实现了搜索功能 fmt.Printf(\u0026#34;search %s for file: %s\\n\u0026#34;, searchText, filepath) fmt.Printf(\u0026#34;file content: %s\\n\u0026#34;, string(content)) } 现在我们来运行一下：\n1 2 3 4 5 6 7 8 go run .\\main.go .\\data\\test1.txt 语言 search 语言 for file: .\\data\\test1.txt file content: Go 编程语言是一个开源项目，旨在提高程序员的生产力。 Go 表达力强、简洁、干净且高效。 其并发机制使编写能充分利用多核和联网机器的程序变得容易，而其新颖的类型系统则支持灵活且模块化的程序构建。 Go 可快速编译为机器代码，但具有垃圾回收的便利性和运行时反射的功能。 它是一种快速、静态类型、编译语言，但感觉像是一种动态类型、解释语言。 现在会打印search 语言 for file: .\\data\\test1.txt 以及完整的文件内容了，但是假如用户忘了输入他想要在哪个文件中搜索呢？\n1 2 3 4 5 6 7 PS D:\\go-project\\minigrep\u0026gt; go run .\\main.go 语言 panic: runtime error: index out of range [2] with length 2 goroutine 1 [running]: main.main() D:/go-project/minigrep/main.go:15 +0x185 exit status 2 oh no, 这是什么？我们作为开发人员当然能看懂这是什么，但是普通用户呢？因此我们除了需要真正实现搜索功能，还应该对这种异常情况做出更友好的提示。此外，我们所有的逻辑都杂糅在main方法中，这也不符合软件工程的最佳实践。\n初步重构，完成功能 首先，我们需要将解析参数、读取文件内容、搜索内容这三个功能拆成不同的模块（func），此外，我们还得适当的处理panic。\n在java中，我们习惯用try-catch语法来捕获异常，再给出合理的错误提示。虽然go语言中也有类似的语法（recover），但是go语言更鼓励显式地处理这种预料之内的异常（即用func返回的error来判断）\n根据这些思路，我们写出了下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func main() { args := os.Args filepath, searchText, err := parseArgs(args) if err != nil { fmt.Println(err) return } content, e := readFile(filepath) if e != nil { fmt.Println(e) return } searchFile(string(content), searchText) } func parseArgs(args []string) (filepath string, searchText string, error error) { if len(args) != 3 { return \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;illegal arguments, should be filepath and searchText\u0026#34;) } // 文件路径 filepath = args[1] searchText = args[2] return filepath, searchText, nil } func searchFile(content string, searchText string) { // go中string类型的空值是\u0026#34;\u0026#34;(空字符串)而不是nil if content == \u0026#34;\u0026#34; { return } lines := strings.Split(content, \u0026#34;\\n\u0026#34;) for _, line := range lines { if strings.Contains(line, searchText) { fmt.Println(line) } } } func readFile(filepath string) (string, error) { // 检查文件是否存在 if _, err := os.Stat(filepath); os.IsNotExist(err) { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;file not found\u0026#34;) } // 检查是否是目录 info, err := os.Stat(filepath) if err == nil \u0026amp;\u0026amp; info.IsDir() { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;is a directory, not a file\u0026#34;) } // 读取文件内容 content, err := os.ReadFile(filepath) if err != nil { if os.IsPermission(err) { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;permission denied\u0026#34;) } return \u0026#34;\u0026#34;, err } return string(content), nil } 添加单元测试 我们可以添加一些单元测试，用以初步验证我们的程序是否有错误。（以下测试代码用AI生成）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 package minigrep import ( \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;testing\u0026#34; ) // TestParseArgs 测试解析命令行参数的功能 func TestParseArgs(t *testing.T) { // 保存原始的命令行参数 oldArgs := os.Args defer func() { os.Args = oldArgs }() // 测试正常情况 os.Args = []string{\u0026#34;minigrep\u0026#34;, \u0026#34;test.txt\u0026#34;, \u0026#34;hello\u0026#34;} filepath, searchText, err := parseArgs(os.Args) if err != nil { t.Errorf(\u0026#34;Expected no error, but got %v\u0026#34;, err) } if filepath != \u0026#34;test.txt\u0026#34; { t.Errorf(\u0026#34;Expected filepath to be \u0026#39;test.txt\u0026#39;, but got %v\u0026#34;, filepath) } if searchText != \u0026#34;hello\u0026#34; { t.Errorf(\u0026#34;Expected searchText to be \u0026#39;hello\u0026#39;, but got %v\u0026#34;, searchText) } // 测试参数数量错误的情况 os.Args = []string{\u0026#34;minigrep\u0026#34;, \u0026#34;test.txt\u0026#34;} _, _, err = parseArgs(os.Args) if err == nil { t.Error(\u0026#34;Expected error for incorrect number of arguments, but got none\u0026#34;) } else if !strings.Contains(err.Error(), \u0026#34;illegal arguments\u0026#34;) { t.Errorf(\u0026#34;Expected error message containing \u0026#39;illegal arguments\u0026#39;, but got \u0026#39;%v\u0026#39;\u0026#34;, err) } } // TestSearchFile 测试在文件内容中搜索文本的功能 func TestSearchFile(t *testing.T) { // 测试包含搜索文本的情况 content := \u0026#34;hello world\\nthis is a test\\ngoodbye world\u0026#34; searchText := \u0026#34;hello\u0026#34; expected := \u0026#34;hello world\\n\u0026#34; // 重定向标准输出以便捕获 r, w, _ := os.Pipe() stdout := os.Stdout os.Stdout = w searchFile(content, searchText) w.Close() os.Stdout = stdout // 读取输出 result, _ := io.ReadAll(r) if string(result) != expected { t.Errorf(\u0026#34;Expected output \u0026#39;%s\u0026#39;, but got \u0026#39;%s\u0026#39;\u0026#34;, expected, string(result)) } // 测试不包含搜索文本的情况 content = \u0026#34;hello world\\nthis is a test\\ngoodbye world\u0026#34; searchText = \u0026#34;missing\u0026#34; r, w, _ = os.Pipe() stdout = os.Stdout os.Stdout = w searchFile(content, searchText) w.Close() os.Stdout = stdout // 读取输出 result, _ = io.ReadAll(r) if len(result) \u0026gt; 0 { t.Errorf(\u0026#34;Expected no output, but got \u0026#39;%s\u0026#39;\u0026#34;, string(result)) } } // TestReadFile 测试读取文件功能 func TestReadFile(t *testing.T) { // 创建临时测试文件 dir := t.TempDir() testFile := dir + \u0026#34;/test.txt\u0026#34; data := \u0026#34;hello world\\nthis is a test\\ngoodbye world\u0026#34; os.WriteFile(testFile, []byte(data), 0644) // 测试正常读取文件 content, err := readFile(testFile) if err != nil { t.Errorf(\u0026#34;Expected no error, but got %v\u0026#34;, err) } if content != data { t.Errorf(\u0026#34;Expected content \u0026#39;%s\u0026#39;, but got \u0026#39;%s\u0026#39;\u0026#34;, data, content) } // 测试读取不存在的文件 _, err = readFile(dir + \u0026#34;/nonexistent.txt\u0026#34;) if err == nil { t.Error(\u0026#34;Expected error for nonexistent file, but got none\u0026#34;) } else if !strings.Contains(err.Error(), \u0026#34;file not found\u0026#34;) { t.Errorf(\u0026#34;Expected error message containing \u0026#39;file not found\u0026#39;, but got \u0026#39;%v\u0026#39;\u0026#34;, err) } // 测试读取目录 _, err = readFile(dir) if err == nil { t.Error(\u0026#34;Expected error for reading directory, but got none\u0026#34;) } else if !strings.Contains(err.Error(), \u0026#34;is a directory\u0026#34;) { t.Errorf(\u0026#34;Expected error message containing \u0026#39;is a directory\u0026#39;, but got \u0026#39;%v\u0026#39;\u0026#34;, err) } } 可以看到：我们的代码通过了测试\n1 2 3 4 5 6 7 8 9 PS D:\\go-project\\minigrep\u0026gt; go test -v === RUN TestParseArgs --- PASS: TestParseArgs (0.00s) === RUN TestSearchFile --- PASS: TestSearchFile (0.00s) === RUN TestReadFile --- PASS: TestReadFile (0.00s) PASS ok minigrep 0.160s 现在，我们可以放心将这个程序交给用户去使用啦（尽管功能简陋），但是我们要如何让用户能使用这个程序呢？\n打包为可执行文件 我们可以用build命令打包为exe，以便用户在一个没有go语言环境的命令行中也能直接执行\n1 2 3 4 5 6 // 打包为exe go build -o minigrep.exe // 使用用例 PS D:\\go-project\\minigrep\u0026gt; .\\minigrep.exe .\\data\\test1.txt 功能 Go 可快速编译为机器代码，但具有垃圾回收的便利性和运行时反射的功能。 总结 通过这个简短的程序，我们初步理解了golang中的func、异常处理、文件系统、赋值、流程控制、字符串处理等基础语法。然而，很多golang的特性、语法我们都没有涉及。此外，这个minigrep甚至不能称之为玩具，功能简陋至极。因此，在下一篇文章中，我们会逐步拓展功能，同时也会涉及更多新语法。\n","date":"2025-05-01T00:00:00Z","permalink":"//ind:1313/p/%E4%BA%94%E5%A4%A9%E9%80%9F%E9%80%9Ago%E4%B8%80--%E6%90%AD%E5%BB%BAmini-grep/","title":"五天速通go(一)--搭建mini-grep"},{"content":"2 应用层 2.1 Web和Http 对http这一套还是非常了解的了。 这节课大致说了请求头、建立连接过程、Cookie等 这是一些之前没注意的细节： http1.0只有POST和GET，Http1.1有PUT、DELETE 后面还讲了一些服务器缓存，涉及到了一个场景的性能提升计算，过于细节没有特别关注。 介绍了缓存的机制（根据时间来判断是否拉新的，状态码304、200）\n2.2 FTP 大概介绍了一下，客户端先和服务断建立控制连接，用于账号密码校验、控制切换目录等，之后再建立数据连接，用于文件传输\n2.3 2.7 TCP套接字编程 主要说了api实现\n服务端：1.创建welcome socket，2绑定了本地端口、ip；3.accept等待客户端连接\n客户端：1.创建socket（操作系统默认隐式绑定本地ip端口）2.connect连接服务端，绑定服务端ip端口\n服务端：收到建立请求后，就会再建一个新的socket来绑定本地、对方ip端口\n之后就是客户端wirte、服务端read，服务端write，客户端read\n之后就是close\n3.1 Ip协议是主机和主机之间的通信\nTCP、UDP是进程和进程之间的通信\nTCP传输的是数据流，没有数据边界；UDP传输的是数据报datagram，每个消息都是独立完整的数据报\nTCP在ip基础上增强了以下能力：更可靠、拥塞流量控制、而UDP则没有在ip基础上提升能力（TCP、UDP都做了多路复用解复用） 但是他们都不能提升带宽、降低延迟\n3.2多路复用、解复用 他们如何在进程中通信？TCP（携带的socket包含了原ip目标ip，原port、目标port）会携带原port、目标port；ip会携带原ip、目标ip，因此当对方收到tcp segment后，自然能通过这四个信息去查到对应的socket和pid；而UDP只携带了socket（原ip、原port）和cad（对方ip、对方prot）；除此之外，当然他们都携带了数据msg\n3.3 无连接UDP UDP （user datagram protocol）因为只在发送、接受时进行了简单的校验运算，所以传输速度很快，没有提供其他高级特性\n为什么UDP 的差错校验机制使用了这样一个复杂的机制？\n假设采用一种更简单的方式：发送端将所有数据每16位进行补和运算，将结果放在一个新的数据段中（假设叫校验码），然后接收端再同样将所有数据每16位进行补和运算，如果结果等于校验，则表明没有出错。这样的方案明显是不充足的，容易引起误判 为什么将数据部分每16位进行补和运算（采用进位回滚的相加并取反），然后与校验码进行相加，一定会等于FFFF？\n将数据部分每16位进行补和运算（采用进位回滚的相加并取反），然后与校验码进行相加，如果等于FFFF就没有出错？\n因为校验码是\n因为这样可以最大化保证校验是有效且快速的？\n3.4可靠数据传输RDP RDP ：reliable datagram protocol\nRDP1.0： 这是一种协议假设，假设消息既不丢失也不出错，这样只需要发送方不停发送消息，接收方不停接受消息即可\nRDP2.0 假设此协议下，消息会发生错误，因此需要协议解决错误\n不出错情况下：消息发送方发送消息，接收方收到消息后，通过校验，发现消息未出错，则返回ack\n出错了：接收方返回nack，则发送方再次发送消息1\nRDP2.1 发送的消息会出错，返回的消息也同样会出错\n假如发送方收到了接收方返回的出错的消息（即无法识别的消息），则默认是nack，即默认发送出错，再次发送0号消息，接受方接受以后，返回ack0，发送方就继续发送msg1。如果实际上没有出错，则接收方丢弃此次消息即可\nRDP2.2 对2.1进行小优化，不发送NACK了，如果出错，返回上一条消息的ACK，比如1号消息出错，返回ACK0\nRDP3.0 此协议下，消息会丢失\n因此引入超时重发机制，假如发送消息后一段时间后，没有返回ack，则说明消息丢失，再次发送即可，假如实际没丢失，只是高延迟，则接收方收到消息丢弃即可\n3.5TCP 报文结构 ip、端口、序号、确认号（序号和确认号都值得是上层下来的数据的数据偏移量）、一些不常用的标志位、以及body\n由于是全双工，所以返回ack的时候用到了确认号，空余量（用于流量控制），同时也有需要返回的真正的数据\n如何控制超时重传？\n发送第一段数据后启动timer，记录返回时间。通过计算类似于平均值与四倍方差的时间来动态计算超时时间。\nTCP是累计确认的。\ntcp提高性能的方法\n1.延迟确认（在某个timer内，等待下一个段数据到来，合并确认，可以减少传输及干扰 或者在timer内都没收到消息，则返回已经到的ack）\n2.乱序确认则立即返回ack上一段\n3.（快速重传）如果超时或收到三个冗余确认，则重发（说明后三段都已经到了，但是所期待的段未ack，则快速重传）\n流量控制：\n返回ACK时顺便带上缓冲区大小\n","date":"2025-05-01T00:00:00Z","permalink":"//ind:1313/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%A7%91%E5%A4%A7%E9%83%91%E7%83%87--%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"计算机网络(中科大郑烇)--个人学习笔记"}]