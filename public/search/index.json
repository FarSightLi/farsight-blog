[{"content":"8 终端和进程组、unix shell 13 多线程编程入门 \u0026hellip;spawn后，共享内存不变，新增新的栈帧\n并发vs并行\n证明了全局变量是共享的、证明栈的大小（不断递归使用栈空间）\n多线程打破了确定性 -\u0026gt; 经典的并发支付、并发sum++\n一个小题目：并发执行三个sum. ,sum的最小值\nt1 t2 t3 t = 0，正常执行++和store，则sum=2 t=0, t+=1,t=1 t=0, t+=1,t=1 再加一次并store，则sum=2 store， sum = 1 store, sum =1 此时load出sum =1（被另外两个线程覆盖了） load后，t=1，再++ load后，t=1，再++ 正常store，再load，再+1，再正常store后，sum=3 正常store，再load，再+1，再正常store后，sum=3 再进行++，t=2，再load，于是sum最终为2 编译器会优化程序 编译器假设，没有什么会随意更改程序状态，那么只要优化前后的程序，在程序调用层面上等价，那么语句其实是可以随意调换删除的\n那么编写程序时，大部分时候希望编译器优化的，毕竟需要性能，那么有两个不推荐的路子：1.插入不可优化的代码块。2.使用volatile关键字\n况且内存也不是真的sharded的，由于物理上的距离、读写的速度，A线程上的内存和B线程上的内存是很有可能不一致的（因为为了保证快，操作系统读取时，是立马返回的，而不是像其他内存块确认是否有修改）\n","date":"2025-05-16T00:00:00Z","permalink":"http://localhost:1313/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%92%8B%E7%82%8E%E7%82%8E--%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"操作系统（南京大学蒋炎炎）--个人学习笔记"},{"content":"前言 笔者有两年Java开发经验，目前需要临时用go语言开发一些功能，为了快速入手Go语言，在简单了解基础语法后，决定以实战来巩固知识。\n参考了《Rust圣经》的思路，决定先开发一个模仿grep的工具，来快速巩固基础语法、Go项目管理。\n为精简内容，本系列不包含环境搭建等基础部分（网上教程写的更清楚详细），直接讲解开发思路。希望能对后来者提供一些入门思路。\n笔者整体思路：大致了解go语言的语法，了解某个工具的大致功能、实现方法。然后再辅以AI语法提示（仅仅告诉某个细节，比如如何读取参数等，而不是直接让ai实现功能）。这样便能快速入门一个不算复杂的语言。\n正文 grep命令简介 grep是一个最初用于Unix操作系统的命令行工具。在给出文件列表或标准输入后，grep会对匹配一个或多个正则表达式的文本进行搜索，并只输出匹配（或者不匹配）的行或文本。\n\u0026ndash; wiki百科\ngrep的一个经典用法是：\n1 grep /data/test.txt searchContent 其中，/data/test.txt 是要搜索的文件列表， searchContent是我们要搜索的内容。这是一种最基本的功能。\n搭建基本框架 我们的minigrep至少要先能获取到用户的目标 :文件列表及搜索内容 \u0026ndash; 即参数列表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 读取参数列表 args := os.Args // 文件路径 filepath := args[1] // 搜索内容 searchText := args[2] content, e := os.ReadFile(filepath) if e != nil { panic(\u0026#34;Usage: illegal file name\u0026#34;) } // 假装已经实现了搜索功能 fmt.Printf(\u0026#34;search %s for file: %s\\n\u0026#34;, searchText, filepath) fmt.Printf(\u0026#34;file content: %s\\n\u0026#34;, string(content)) } 现在我们来运行一下：\n1 2 3 4 5 6 7 8 go run .\\main.go .\\data\\test1.txt 语言 search 语言 for file: .\\data\\test1.txt file content: Go 编程语言是一个开源项目，旨在提高程序员的生产力。 Go 表达力强、简洁、干净且高效。 其并发机制使编写能充分利用多核和联网机器的程序变得容易，而其新颖的类型系统则支持灵活且模块化的程序构建。 Go 可快速编译为机器代码，但具有垃圾回收的便利性和运行时反射的功能。 它是一种快速、静态类型、编译语言，但感觉像是一种动态类型、解释语言。 现在会打印search 语言 for file: .\\data\\test1.txt 以及完整的文件内容了，但是假如用户忘了输入他想要在哪个文件中搜索呢？\n1 2 3 4 5 6 7 PS D:\\go-project\\minigrep\u0026gt; go run .\\main.go 语言 panic: runtime error: index out of range [2] with length 2 goroutine 1 [running]: main.main() D:/go-project/minigrep/main.go:15 +0x185 exit status 2 oh no, 这是什么？我们作为开发人员当然能看懂这是什么，但是普通用户呢？因此我们除了需要真正实现搜索功能，还应该对这种异常情况做出更友好的提示。此外，我们所有的逻辑都杂糅在main方法中，这也不符合软件工程的最佳实践。\n初步重构，完成功能 首先，我们需要将解析参数、读取文件内容、搜索内容这三个功能拆成不同的模块（func），此外，我们还得适当的处理panic。\n在java中，我们习惯用try-catch语法来捕获异常，再给出合理的错误提示。虽然go语言中也有类似的语法（recover），但是go语言更鼓励显式地处理这种预料之内的异常（即用func返回的error来判断）\n根据这些思路，我们写出了下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func main() { args := os.Args filepath, searchText, err := parseArgs(args) if err != nil { fmt.Println(err) return } content, e := readFile(filepath) if e != nil { fmt.Println(e) return } searchFile(string(content), searchText) } func parseArgs(args []string) (filepath string, searchText string, error error) { if len(args) != 3 { return \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;illegal arguments, should be filepath and searchText\u0026#34;) } // 文件路径 filepath = args[1] searchText = args[2] return filepath, searchText, nil } func searchFile(content string, searchText string) { // go中string类型的空值是\u0026#34;\u0026#34;(空字符串)而不是nil if content == \u0026#34;\u0026#34; { return } lines := strings.Split(content, \u0026#34;\\n\u0026#34;) for _, line := range lines { if strings.Contains(line, searchText) { fmt.Println(line) } } } func readFile(filepath string) (string, error) { // 检查文件是否存在 if _, err := os.Stat(filepath); os.IsNotExist(err) { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;file not found\u0026#34;) } // 检查是否是目录 info, err := os.Stat(filepath) if err == nil \u0026amp;\u0026amp; info.IsDir() { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;is a directory, not a file\u0026#34;) } // 读取文件内容 content, err := os.ReadFile(filepath) if err != nil { if os.IsPermission(err) { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;permission denied\u0026#34;) } return \u0026#34;\u0026#34;, err } return string(content), nil } 添加单元测试 我们可以添加一些单元测试，用以初步验证我们的程序是否有错误。（以下测试代码用AI生成）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 package minigrep import ( \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;testing\u0026#34; ) // TestParseArgs 测试解析命令行参数的功能 func TestParseArgs(t *testing.T) { // 保存原始的命令行参数 oldArgs := os.Args defer func() { os.Args = oldArgs }() // 测试正常情况 os.Args = []string{\u0026#34;minigrep\u0026#34;, \u0026#34;test.txt\u0026#34;, \u0026#34;hello\u0026#34;} filepath, searchText, err := parseArgs(os.Args) if err != nil { t.Errorf(\u0026#34;Expected no error, but got %v\u0026#34;, err) } if filepath != \u0026#34;test.txt\u0026#34; { t.Errorf(\u0026#34;Expected filepath to be \u0026#39;test.txt\u0026#39;, but got %v\u0026#34;, filepath) } if searchText != \u0026#34;hello\u0026#34; { t.Errorf(\u0026#34;Expected searchText to be \u0026#39;hello\u0026#39;, but got %v\u0026#34;, searchText) } // 测试参数数量错误的情况 os.Args = []string{\u0026#34;minigrep\u0026#34;, \u0026#34;test.txt\u0026#34;} _, _, err = parseArgs(os.Args) if err == nil { t.Error(\u0026#34;Expected error for incorrect number of arguments, but got none\u0026#34;) } else if !strings.Contains(err.Error(), \u0026#34;illegal arguments\u0026#34;) { t.Errorf(\u0026#34;Expected error message containing \u0026#39;illegal arguments\u0026#39;, but got \u0026#39;%v\u0026#39;\u0026#34;, err) } } // TestSearchFile 测试在文件内容中搜索文本的功能 func TestSearchFile(t *testing.T) { // 测试包含搜索文本的情况 content := \u0026#34;hello world\\nthis is a test\\ngoodbye world\u0026#34; searchText := \u0026#34;hello\u0026#34; expected := \u0026#34;hello world\\n\u0026#34; // 重定向标准输出以便捕获 r, w, _ := os.Pipe() stdout := os.Stdout os.Stdout = w searchFile(content, searchText) w.Close() os.Stdout = stdout // 读取输出 result, _ := io.ReadAll(r) if string(result) != expected { t.Errorf(\u0026#34;Expected output \u0026#39;%s\u0026#39;, but got \u0026#39;%s\u0026#39;\u0026#34;, expected, string(result)) } // 测试不包含搜索文本的情况 content = \u0026#34;hello world\\nthis is a test\\ngoodbye world\u0026#34; searchText = \u0026#34;missing\u0026#34; r, w, _ = os.Pipe() stdout = os.Stdout os.Stdout = w searchFile(content, searchText) w.Close() os.Stdout = stdout // 读取输出 result, _ = io.ReadAll(r) if len(result) \u0026gt; 0 { t.Errorf(\u0026#34;Expected no output, but got \u0026#39;%s\u0026#39;\u0026#34;, string(result)) } } // TestReadFile 测试读取文件功能 func TestReadFile(t *testing.T) { // 创建临时测试文件 dir := t.TempDir() testFile := dir + \u0026#34;/test.txt\u0026#34; data := \u0026#34;hello world\\nthis is a test\\ngoodbye world\u0026#34; os.WriteFile(testFile, []byte(data), 0644) // 测试正常读取文件 content, err := readFile(testFile) if err != nil { t.Errorf(\u0026#34;Expected no error, but got %v\u0026#34;, err) } if content != data { t.Errorf(\u0026#34;Expected content \u0026#39;%s\u0026#39;, but got \u0026#39;%s\u0026#39;\u0026#34;, data, content) } // 测试读取不存在的文件 _, err = readFile(dir + \u0026#34;/nonexistent.txt\u0026#34;) if err == nil { t.Error(\u0026#34;Expected error for nonexistent file, but got none\u0026#34;) } else if !strings.Contains(err.Error(), \u0026#34;file not found\u0026#34;) { t.Errorf(\u0026#34;Expected error message containing \u0026#39;file not found\u0026#39;, but got \u0026#39;%v\u0026#39;\u0026#34;, err) } // 测试读取目录 _, err = readFile(dir) if err == nil { t.Error(\u0026#34;Expected error for reading directory, but got none\u0026#34;) } else if !strings.Contains(err.Error(), \u0026#34;is a directory\u0026#34;) { t.Errorf(\u0026#34;Expected error message containing \u0026#39;is a directory\u0026#39;, but got \u0026#39;%v\u0026#39;\u0026#34;, err) } } 可以看到：我们的代码通过了测试\n1 2 3 4 5 6 7 8 9 PS D:\\go-project\\minigrep\u0026gt; go test -v === RUN TestParseArgs --- PASS: TestParseArgs (0.00s) === RUN TestSearchFile --- PASS: TestSearchFile (0.00s) === RUN TestReadFile --- PASS: TestReadFile (0.00s) PASS ok minigrep 0.160s 现在，我们可以放心将这个程序交给用户去使用啦（尽管功能简陋），但是我们要如何让用户能使用这个程序呢？\n打包为可执行文件 我们可以用build命令打包为exe，以便用户在一个没有go语言环境的命令行中也能直接执行\n1 2 3 4 5 6 // 打包为exe go build -o minigrep.exe // 使用用例 PS D:\\go-project\\minigrep\u0026gt; .\\minigrep.exe .\\data\\test1.txt 功能 Go 可快速编译为机器代码，但具有垃圾回收的便利性和运行时反射的功能。 总结 通过这个简短的程序，我们初步理解了golang中的func、异常处理、文件系统、赋值、流程控制、字符串处理等基础语法。然而，很多golang的特性、语法我们都没有涉及。此外，这个minigrep甚至不能称之为玩具，功能简陋至极。因此，在下一篇文章中，我们会逐步拓展功能，同时也会涉及更多新语法。\n","date":"2025-05-01T00:00:00Z","permalink":"http://localhost:1313/p/%E4%BA%94%E5%A4%A9%E9%80%9F%E9%80%9Ago%E4%B8%80--%E6%90%AD%E5%BB%BAmini-grep/","title":"五天速通go(一)--搭建mini-grep"},{"content":"2 应用层 2.1 Web和Http 对http这一套还是非常了解的了。 这节课大致说了请求头、建立连接过程、Cookie等 这是一些之前没注意的细节： http1.0只有POST和GET，Http1.1有PUT、DELETE 后面还讲了一些服务器缓存，涉及到了一个场景的性能提升计算，过于细节没有特别关注。 介绍了缓存的机制（根据时间来判断是否拉新的，状态码304、200）\n2.2 FTP 大概介绍了一下，客户端先和服务断建立控制连接，用于账号密码校验、控制切换目录等，之后再建立数据连接，用于文件传输\n2.3 2.7 TCP套接字编程 主要说了api实现\n服务端：1.创建welcome socket，2绑定了本地端口、ip；3.accept等待客户端连接\n客户端：1.创建socket（操作系统默认隐式绑定本地ip端口）2.connect连接服务端，绑定服务端ip端口\n服务端：收到建立请求后，就会再建一个新的socket来绑定本地、对方ip端口\n之后就是客户端wirte、服务端read，服务端write，客户端read\n之后就是close\n3.1 Ip协议是主机和主机之间的通信\nTCP、UDP是进程和进程之间的通信\nTCP传输的是数据流，没有数据边界；UDP传输的是数据报datagram，每个消息都是独立完整的数据报\nTCP在ip基础上增强了以下能力：更可靠、拥塞流量控制、而UDP则没有在ip基础上提升能力（TCP、UDP都做了多路复用解复用） 但是他们都不能提升带宽、降低延迟\n3.2多路复用、解复用 他们如何在进程中通信？TCP（携带的socket包含了原ip目标ip，原port、目标port）会携带原port、目标port；ip会携带原ip、目标ip，因此当对方收到tcp segment后，自然能通过这四个信息去查到对应的socket和pid；而UDP只携带了socket（原ip、原port）和cad（对方ip、对方prot）；除此之外，当然他们都携带了数据msg\n3.3 无连接UDP UDP （user datagram protocol）因为只在发送、接受时进行了简单的校验运算，所以传输速度很快，没有提供其他高级特性\n为什么UDP 的差错校验机制使用了这样一个复杂的机制？\n假设采用一种更简单的方式：发送端将所有数据每16位进行补和运算，将结果放在一个新的数据段中（假设叫校验码），然后接收端再同样将所有数据每16位进行补和运算，如果结果等于校验，则表明没有出错。这样的方案明显是不充足的，容易引起误判 为什么将数据部分每16位进行补和运算（采用进位回滚的相加并取反），然后与校验码进行相加，一定会等于FFFF？\n将数据部分每16位进行补和运算（采用进位回滚的相加并取反），然后与校验码进行相加，如果等于FFFF就没有出错？\n因为校验码是\n因为这样可以最大化保证校验是有效且快速的？\n3.4可靠数据传输RDP RDP ：reliable datagram protocol\nRDP1.0： 这是一种协议假设，假设消息既不丢失也不出错，这样只需要发送方不停发送消息，接收方不停接受消息即可\nRDP2.0 假设此协议下，消息会发生错误，因此需要协议解决错误\n不出错情况下：消息发送方发送消息，接收方收到消息后，通过校验，发现消息未出错，则返回ack\n出错了：接收方返回nack，则发送方再次发送消息1\nRDP2.1 发送的消息会出错，返回的消息也同样会出错\n假如发送方收到了接收方返回的出错的消息（即无法识别的消息），则默认是nack，即默认发送出错，再次发送0号消息，接受方接受以后，返回ack0，发送方就继续发送msg1。如果实际上没有出错，则接收方丢弃此次消息即可\nRDP2.2 对2.1进行小优化，不发送NACK了，如果出错，返回上一条消息的ACK，比如1号消息出错，返回ACK0\nRDP3.0 此协议下，消息会丢失\n因此引入超时重发机制，假如发送消息后一段时间后，没有返回ack，则说明消息丢失，再次发送即可，假如实际没丢失，只是高延迟，则接收方收到消息丢弃即可\n3.5TCP 报文结构 ip、端口、序号、确认号（序号和确认号都值得是上层下来的数据的数据偏移量）、一些不常用的标志位、以及body\n由于是全双工，所以返回ack的时候用到了确认号，空余量（用于流量控制），同时也有需要返回的真正的数据\n如何控制超时重传？\n发送第一段数据后启动timer，记录返回时间。通过计算类似于平均值与四倍方差的时间来动态计算超时时间。\nTCP是累计确认的。\ntcp提高性能的方法\n1.延迟确认（在某个timer内，等待下一个段数据到来，合并确认，可以减少传输及干扰 或者在timer内都没收到消息，则返回已经到的ack）\n2.乱序确认则立即返回ack上一段\n3.（快速重传）如果超时或收到三个冗余确认，则重发（说明后三段都已经到了，但是所期待的段未ack，则快速重传）\n流量控制：\n返回ACK时顺便带上缓冲区大小\n","date":"2025-05-01T00:00:00Z","permalink":"http://localhost:1313/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%A7%91%E5%A4%A7%E9%83%91%E7%83%87--%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"计算机网络(中科大郑烇)--个人学习笔记"}]